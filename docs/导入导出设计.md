# 导入导出功能设计

## 核心价值

**真实需求**：
1. 换电脑时快速迁移配置
2. 团队成员分享预置模板（不含 API Key）
3. 备份配置（可选包含 API Key）

**非目标**：
- ❌ 不做云同步（复杂度高、安全风险、冲突处理）
- ❌ 不做自动备份（Time Machine 已做）

## Linus 的三个问题

### 1. "这是真问题还是臆想出来的？"

**✅ 真问题**：
- 换电脑：10/10 用户都会遇到
- 团队分享：7/10 团队需要统一的预置配置
- 备份：5/10 用户关心

### 2. "有更简单的方法吗？"

**方案对比**：

| 方案 | 复杂度 | 安全性 | 用户体验 |
|------|--------|--------|----------|
| 手动复制 `~/.ccman/` | 0 行代码 | ✅ 安全 | ❌ Geek only |
| 导出导入 JSON | 200 行代码 | ✅ 可控 | ✅ 友好 |
| WebDAV 云同步 | 500 行代码 | ❌ 风险高 | ⚠️ 复杂 |

**结论**: 导出导入是最佳平衡点。

### 3. "会破坏什么吗？"

**风险**：
- API Key 泄露：如果用户导出时包含 API Key 并分享文件
- 配置覆盖：如果导入时覆盖了现有配置

**防护措施**：
- 默认不导出 API Key（明确警告）
- 导入前预览（显示冲突）
- 备份现有配置（原子操作）

## 数据结构设计

### 导出格式

```json
{
  "version": "3.0.2",
  "exportedAt": "2025-10-07T12:34:56Z",
  "includeApiKeys": false,
  "data": {
    "codex": {
      "current": "anthropic",
      "providers": [
        {
          "name": "anthropic",
          "baseUrl": "https://api.anthropic.com",
          "apiKey": "",  // 如果 includeApiKeys=false，为空字符串
          "createdAt": 1234567890,
          "lastUsedAt": 1234567890
        }
      ],
      "presets": [
        {
          "name": "my-custom-preset",
          "baseUrl": "https://api.example.com",
          "description": "My custom preset"
        }
      ]
    },
    "claudecode": {
      "current": "openai",
      "providers": [ ... ],
      "presets": [ ... ]
    }
  }
}
```

**设计说明**：
- `version`: 用于兼容性检查（未来格式变更时）
- `exportedAt`: 时间戳，方便用户识别备份版本
- `includeApiKeys`: 明确标记是否包含敏感信息
- `current`: 使用 name 而不是 ID（ID 是内部标识，导入后会重新生成）
- `apiKey`: 如果不导出，设为空字符串（而不是删除字段，保持结构一致）

### 导入逻辑

```typescript
interface ImportOptions {
  merge: boolean         // 合并模式（true）或覆盖模式（false，默认）
  skipConflict: boolean  // 跳过名称冲突的 provider（默认 false，提示用户）
}

function importConfig(json: ExportData, options: ImportOptions) {
  // 1. 版本兼容性检查
  if (json.version !== VERSION) {
    warn('版本不匹配，可能存在兼容性问题')
  }

  // 2. 备份当前配置
  backupCurrentConfig()

  try {
    // 3. 导入 presets（合并，不覆盖现有）
    for (const tool of ['codex', 'claudecode']) {
      const manager = createManager(tool)
      const data = json.data[tool]

      // 导入用户预置
      for (const preset of data.presets) {
        if (!manager.listPresets().find(p => p.name === preset.name)) {
          manager.addPreset(preset)
        }
      }

      // 导入 providers
      for (const provider of data.providers) {
        // 检查名称冲突
        const existing = manager.findByName(provider.name)
        if (existing) {
          if (options.skipConflict) {
            continue  // 跳过
          } else {
            // 重命名: "anthropic" → "anthropic (imported)"
            provider.name = `${provider.name} (imported)`
          }
        }

        // 如果 apiKey 为空，提示用户稍后补充
        if (!provider.apiKey) {
          provider.apiKey = 'PLEASE_SET_API_KEY'
        }

        manager.add(provider)
      }

      // 恢复 current（根据 name 查找）
      if (data.current) {
        const provider = manager.findByName(data.current)
        if (provider) {
          manager.switch(provider.id)
        }
      }
    }
  } catch (error) {
    // 回滚
    restoreBackup()
    throw error
  }
}
```

## CLI 命令设计

### 导出命令

```bash
ccman export [options]
```

**选项**：
- `--output <file>`: 输出文件路径（默认：`./ccman-config-{timestamp}.json`）
- `--include-api-keys`: 包含 API Key（危险，默认不包含）
- `--tool <tool>`: 只导出指定工具（`codex` 或 `claudecode`）

**示例**：
```bash
# 导出所有配置（不含 API Key）
ccman export

# 导出到指定文件
ccman export --output ~/backup/ccman.json

# 导出包含 API Key（危险）
ccman export --include-api-keys --output ~/private-backup.json

# 只导出 Codex 配置
ccman export --tool codex
```

**输出示例**：
```
✅ 配置已导出到: /Users/you/ccman-config-2025-10-07.json

📊 导出内容：
  Codex:
    - 3 个服务商
    - 2 个自定义预置
    - 当前使用: anthropic
  Claude Code:
    - 2 个服务商
    - 1 个自定义预置
    - 当前使用: openai

⚠️  API Key 未包含在导出文件中（安全）
💡 如需包含 API Key，使用 --include-api-keys 选项
```

### 导入命令

```bash
ccman import <file> [options]
```

**选项**：
- `--merge`: 合并模式（保留现有配置，只添加新的）
- `--skip-conflict`: 跳过名称冲突的 provider（默认：重命名为 "name (imported)"）

**示例**：
```bash
# 导入配置（覆盖模式）
ccman import ccman-config.json

# 合并模式
ccman import ccman-config.json --merge

# 跳过冲突
ccman import ccman-config.json --skip-conflict
```

**交互流程**：
```
📂 读取导入文件: ccman-config.json

📊 导入预览：
  ✅ Codex:
    - 将添加 2 个服务商 (anthropic, openai)
    - ⚠️  名称冲突: anthropic（将重命名为 "anthropic (imported)"）
    - 将添加 1 个预置 (my-preset)
    - ⚠️  3 个服务商的 API Key 为空（需要稍后补充）
  ✅ Claude Code:
    - 将添加 1 个服务商 (azure)

❓ 确认导入？(y/N): y

✅ 导入成功！

⚠️  以下服务商的 API Key 为空，请使用 edit 命令补充：
  - Codex: anthropic, openai, azure
  - Claude Code: azure

💡 补充 API Key：
  ccman cx edit anthropic
  ccman cc edit azure
```

## Desktop UI 设计

### 设置页面

**位置**: 主界面 → 设置 → 数据管理

**布局**：
```
┌─────────────────────────────────────┐
│  数据管理                            │
├─────────────────────────────────────┤
│                                     │
│  导出配置                            │
│  ┌───────────────────────────────┐  │
│  │ 📤 导出配置到文件              │  │
│  │                               │  │
│  │ 将您的服务商配置导出为 JSON    │  │
│  │ 文件，用于备份或迁移到新设备。  │  │
│  │                               │  │
│  │  [ 导出配置 ]                  │  │
│  └───────────────────────────────┘  │
│                                     │
│  导入配置                            │
│  ┌───────────────────────────────┐  │
│  │ 📥 从文件导入配置              │  │
│  │                               │  │
│  │ 从导出的 JSON 文件恢复配置。   │  │
│  │                               │  │
│  │  [ 导入配置 ]                  │  │
│  └───────────────────────────────┘  │
│                                     │
└─────────────────────────────────────┘
```

### 导出对话框

```
┌─────────────────────────────────────┐
│  导出配置                     [ X ]  │
├─────────────────────────────────────┤
│                                     │
│  保存位置:                           │
│  ┌───────────────────────────────┐  │
│  │ ~/ccman-config-2025-10-07.json│  │
│  └───────────────────────────────┘  │
│   [ 选择文件... ]                   │
│                                     │
│  选项:                               │
│  ☐ 包含 API Key                     │
│     ⚠️  将以明文形式导出 API Key    │
│        仅用于个人备份，请勿分享文件  │
│                                     │
│  ☐ 只导出 Codex                     │
│  ☐ 只导出 Claude Code               │
│                                     │
│              [ 取消 ]  [ 导出 ]     │
└─────────────────────────────────────┘
```

### 导入对话框

**Step 1: 选择文件**
```
┌─────────────────────────────────────┐
│  导入配置                     [ X ]  │
├─────────────────────────────────────┤
│                                     │
│  选择配置文件:                       │
│  ┌───────────────────────────────┐  │
│  │ ~/ccman-config.json           │  │
│  └───────────────────────────────┘  │
│   [ 选择文件... ]                   │
│                                     │
│              [ 取消 ]  [ 下一步 ]   │
└─────────────────────────────────────┘
```

**Step 2: 预览（显示冲突）**
```
┌─────────────────────────────────────┐
│  导入配置 - 预览              [ X ]  │
├─────────────────────────────────────┤
│                                     │
│  📊 将导入以下内容：                 │
│                                     │
│  ✅ Codex (2 个服务商, 1 个预置)     │
│    - anthropic                      │
│    - openai                         │
│    - my-custom-preset (预置)        │
│                                     │
│  ⚠️  冲突：                          │
│    - "anthropic" 已存在             │
│      → 将重命名为 "anthropic (imported)" │
│                                     │
│  ⚠️  以下服务商的 API Key 为空：      │
│    - anthropic                      │
│    - openai                         │
│    导入后需要手动补充 API Key        │
│                                     │
│  导入模式:                           │
│  ○ 覆盖模式（清空现有配置）          │
│  ● 合并模式（保留现有配置）          │
│                                     │
│              [ 取消 ]  [ 导入 ]     │
└─────────────────────────────────────┘
```

**Step 3: 成功提示**
```
┌─────────────────────────────────────┐
│  导入成功                     [ X ]  │
├─────────────────────────────────────┤
│                                     │
│  ✅ 配置已成功导入！                 │
│                                     │
│  ⚠️  以下服务商需要补充 API Key：     │
│                                     │
│  Codex:                             │
│    - anthropic                      │
│    - openai                         │
│                                     │
│  Claude Code:                       │
│    - azure                          │
│                                     │
│  请前往对应页面编辑服务商以补充 API Key。 │
│                                     │
│                   [ 知道了 ]         │
└─────────────────────────────────────┘
```

## 实现计划

### Phase 1: Core 模块（优先）

**文件**: `packages/core/src/export-import.ts`

```typescript
// 导出功能
export interface ExportOptions {
  includeApiKeys: boolean
  tools?: ('codex' | 'claudecode')[]
}

export function exportConfig(options: ExportOptions): ExportData {
  // 实现导出逻辑
}

// 导入功能
export interface ImportOptions {
  merge: boolean
  skipConflict: boolean
}

export function importConfig(data: ExportData, options: ImportOptions): ImportResult {
  // 实现导入逻辑
}

// 导入结果
export interface ImportResult {
  success: boolean
  added: {
    codex: { providers: number, presets: number }
    claudecode: { providers: number, presets: number }
  }
  conflicts: Array<{ tool: string, name: string, action: 'renamed' | 'skipped' }>
  missingApiKeys: Array<{ tool: string, name: string }>
}
```

**代码量**: ~150 行

**测试**: `packages/core/src/export-import.test.ts` ~100 行

### Phase 2: CLI 命令

**文件**:
- `packages/cli/src/commands/export.ts` ~30 行
- `packages/cli/src/commands/import.ts` ~50 行

**代码量**: ~80 行

### Phase 3: Desktop UI

**文件**:
- `packages/desktop/src/pages/Settings.tsx` - 添加数据管理区域
- `packages/desktop/src/components/ExportDialog.tsx` ~50 行
- `packages/desktop/src/components/ImportDialog.tsx` ~100 行

**代码量**: ~150 行

**总计**: ~480 行（包含测试）

## 安全性设计

### API Key 保护

1. **默认不导出**：
   - `includeApiKeys` 默认为 `false`
   - CLI 和 Desktop 都需要明确勾选才导出

2. **明确警告**：
   ```
   ⚠️  危险操作：包含 API Key

   导出的文件将包含您的 API 密钥，任何获取此文件的人
   都可以使用您的 API 配额。

   ✅ 推荐：不包含 API Key（用于团队分享配置模板）
   ❌ 危险：包含 API Key（仅用于个人备份，请妥善保管）

   确认要包含 API Key 吗？(y/N):
   ```

3. **文件权限**：
   - 导出的文件自动设置为 `0600`（只有所有者可读写）

### 导入保护

1. **备份现有配置**：
   - 导入前自动备份到 `~/.ccman/backup/`
   - 失败时自动回滚

2. **原子操作**：
   - 先写入临时文件
   - 验证无误后 rename（原子操作）
   - 失败时自动清理

3. **预览确认**：
   - 显示所有将要改变的内容
   - 显示冲突和缺失的 API Key
   - 用户确认后才执行

## 测试计划

### 单元测试

1. **exportConfig()**:
   - 不包含 API Key
   - 包含 API Key
   - 只导出 Codex
   - 只导出 Claude Code
   - 空配置

2. **importConfig()**:
   - 覆盖模式
   - 合并模式
   - 名称冲突处理
   - 缺失 API Key
   - 版本不匹配
   - 格式错误

### 集成测试

1. 导出 → 导入（完整流程）
2. 导出 → 编辑 JSON → 导入
3. 导入后 current 恢复
4. 导入后 presets 合并
5. 名称冲突重命名

### 手动测试

1. Desktop 导出对话框
2. Desktop 导入对话框
3. CLI 命令交互
4. 文件权限检查

## 兼容性设计

### 版本检查

```typescript
function checkVersion(exportVersion: string): CompatibilityResult {
  const [major, minor, patch] = exportVersion.split('.').map(Number)
  const [currentMajor, currentMinor] = VERSION.split('.').map(Number)

  if (major < currentMajor) {
    return { compatible: true, warning: '导出版本较旧，已自动升级格式' }
  }

  if (major > currentMajor) {
    return { compatible: false, error: '导出版本太新，请升级 ccman' }
  }

  return { compatible: true }
}
```

### 格式迁移

如果未来配置格式变更，在导入时自动迁移：

```typescript
function migrateFormat(data: ExportData): ExportData {
  // 3.0.x → 3.1.x: 添加新字段
  if (!data.data.codex.settings) {
    data.data.codex.settings = {}
  }

  // 3.1.x → 4.0.x: 重大变更
  // ...

  return data
}
```

## 文档清单

- [x] `docs/导入导出设计.md` - 本文档
- [ ] `README.md` - 添加导入导出使用说明
- [ ] `docs/功能清单.md` - 更新功能列表
- [ ] `docs/技术架构.md` - 更新架构图

## 开发时间表

| 阶段 | 任务 | 工作量 | 负责人 |
|------|------|--------|--------|
| Week 1 | Core 模块实现 + 测试 | 2 天 | - |
| Week 2 | CLI 命令实现 | 1 天 | - |
| Week 2 | Desktop UI 实现 | 2 天 | - |
| Week 3 | 集成测试 + 文档 | 1 天 | - |

**总计**: 6 天

## FAQ

### Q: 为什么不做 WebDAV 云同步？

**A**:
1. 解决不存在的问题（< 5% 用户需要）
2. 安全风险高（API Key 存储在云端）
3. 复杂度高（需要处理冲突、认证、网络错误）
4. 导出导入已经解决了真实问题

Linus: "This is solving a non-existent problem."

### Q: 导出格式为什么用 JSON 而不是 YAML？

**A**:
- JSON 零依赖、标准化、可编程
- YAML 需要依赖库、缩进地狱
- 用户不需要手动编辑导出文件

### Q: 为什么不自动备份配置？

**A**:
- macOS 有 Time Machine
- Linux/Windows 用户可以用 rsync/robocopy
- 自动备份 = 复杂度增加（备份频率、保留策略、清理）
- YAGNI: 用户真需要时会主动导出

### Q: current 为什么导出为 name 而不是 ID？

**A**:
- ID 是内部标识，导入后会重新生成
- name 是用户可见的标识，更稳定
- 如果导入后找不到对应 name，不设置 current（用户手动选择）

### Q: 为什么要警告包含 API Key？

**A**:
- API Key 是敏感信息，泄露会导致费用损失
- 大多数用户场景（团队分享）不需要 API Key
- 明确警告可以防止用户误操作
