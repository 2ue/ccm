# ccman 架构设计方案

> **版本**: v2.0
> **日期**: 2025-01-07
> **状态**: 最终方案

## 目录

- [一、核心设计原则](#一核心设计原则)
- [二、整体架构](#二整体架构)
- [三、命令结构设计](#三命令结构设计)
- [四、数据结构设计](#四数据结构设计)
- [五、环境配置方案](#五环境配置方案)
- [六、模块详细设计](#六模块详细设计)
- [七、工作流程](#七工作流程)
- [八、代码示例](#八代码示例)
- [九、测试策略](#九测试策略)
- [十、与旧设计的对比](#十与旧设计的对比)

---

## 一、核心设计原则

### 1.1 架构分层原则

```
User Interface Layer (用户界面层)
  - Desktop (Electron 图形界面)
  - CLI (命令行界面)
  ↓ 只调用 Core API
Core Layer (核心业务层)
  ├── Business Logic (业务逻辑)
  │   - tool-manager.ts (工厂函数)
  │   - config/ (配置文件读写)
  │   - presets/ (预设服务商)
  │   - paths.ts (环境感知路径)
  │
  └── Writers (外部集成 - Core 的内部模块)
      - writers/codex.ts
      - writers/claudecode.ts
```

**职责清晰**：
- **User Interface Layer**:
  - Desktop: Electron 图形界面，通过 IPC 调用 Core
  - CLI: 命令行界面，直接调用 Core
- **Core Layer**:
  - 管理 ccman 自己的数据（`~/.ccman/`）
  - 提供统一的 API（`codex.*`, `claudeCode.*`）
  - **包含 Writers 模块**：负责写入外部工具配置（`~/.codex/`, `~/.claude/`）

**重要说明**：Writers 不是独立的一层，而是 **Core 的内部模块**（位于 `packages/core/src/writers/`）

### 1.2 数据分离原则

- Codex 和 Claude Code 的数据**完全分离**
- 两个独立的配置文件：`codex.json`, `claudecode.json`
- 两套独立的预设服务商：`CODEX_PRESETS`, `CLAUDECODE_PRESETS`
- 两套独立的 API：`codex.*`, `claudeCode.*`

### 1.3 环境隔离原则

- 开发环境 (`development`)：使用独立的测试目录
- 测试环境 (`test`)：使用临时目录（自动清理）
- 生产环境 (`production`)：使用正式目录（`~/.ccman/`, `~/.codex/`, `~/.claude/`）

**核心要求**：开发和测试环境**绝不能影响**正式环境的配置文件。

### 1.4 命名规范原则

**重要**：Claude Code ≠ Claude
- Claude Code 是工具名（和 Codex 平级）
- Claude 是 AI 模型名

**命名规范**：

| 位置 | 正确命名 | 错误命名 | 说明 |
|------|----------|----------|------|
| CLI 命令 | `ccman cx`, `ccman cc` | ❌ `ccman claude` | 命令用缩写 |
| 类型定义 | `'codex' \| 'claudecode'` | ❌ `'claude'` | 类型用全称小写 |
| 变量名 | `codex`, `claudeCode` | ❌ `claude` | 变量用驼峰 |
| 配置文件 | `codex.json`, `claudecode.json` | ❌ `claude.json` | 文件用全称小写 |
| 函数名 | `writeClaudeCodeConfig()` | ❌ `writeClaudeConfig()` | 函数用全称驼峰 |
| 常量名 | `CLAUDECODE_PRESETS` | ❌ `CLAUDE_PRESETS` | 常量用全称大写 |

### 1.5 简洁性原则

> "Bad programmers worry about the code. Good programmers worry about data structures." - Linus Torvalds

- 优先使用**函数式**，而不是面向对象（接口 + 类）
- 只有 2 个工具，不需要过度抽象
- 用**工厂函数**生成两套 API，而不是适配器模式
- 代码量目标：Core 层 < 200 行

---

## 二、整体架构

### 2.1 完整架构图（包含 Desktop）

```
┌────────────────────────────────────────────────────────────────┐
│              User Interface Layer (用户界面层)                  │
│                                                                │
│  ┌─────────────────────────┬──────────────────────────┐       │
│  │   Desktop (Electron)    │      CLI (Node.js)       │       │
│  │  (packages/desktop/)    │    (packages/cli/)       │       │
│  │                         │                          │       │
│  │  ┌──────────────────┐   │  commands/               │       │
│  │  │ Renderer (React) │   │  ├── codex.ts            │       │
│  │  │ - CodexPanel     │   │  ├── claudecode.ts       │       │
│  │  │ - ClaudeCodePanel│   │  └── status.ts           │       │
│  │  └──────────────────┘   │                          │       │
│  │          ↓ IPC          │  特点：                  │       │
│  │  ┌──────────────────┐   │  - 交互式输入(inquirer)  │       │
│  │  │ Preload Script   │   │  - 直接调用 Core        │       │
│  │  └──────────────────┘   │                          │       │
│  │          ↓ IPC          │                          │       │
│  │  ┌──────────────────┐   │                          │       │
│  │  │ Main (Node.js)   │   │                          │       │
│  │  │ - IPC Handlers   │   │                          │       │
│  │  │ - 直接调用 Core  │   │                          │       │
│  │  └──────────────────┘   │                          │       │
│  └─────────────────────────┴──────────────────────────┘       │
│              ↓                         ↓                       │
│         import Core               import Core                  │
└────────────────────────────────────────────────────────────────┘
                              ↓
┌────────────────────────────────────────────────────────────────┐
│                  Core Layer (核心业务层)                        │
│                  (packages/core/src/)                          │
│                                                                │
│  ┌──────────────────────────────────────────────────────┐     │
│  │ Business Logic (业务逻辑)                            │     │
│  │                                                      │     │
│  │  tool-manager.ts（工厂函数 - 核心逻辑）              │     │
│  │    createToolManager(tool: ToolType) → ToolManager  │     │
│  │                                                      │     │
│  │  导出 API：                                          │     │
│  │    export const codex = createToolManager('codex')  │     │
│  │    export const claudeCode = ...('claudecode')      │     │
│  │                                                      │     │
│  │  config/（配置文件读写）                             │     │
│  │    ├── codex.ts        ~/.ccman/codex.json         │     │
│  │    └── claudecode.ts   ~/.ccman/claudecode.json    │     │
│  │                                                      │     │
│  │  presets/（预设服务商）                              │     │
│  │    ├── codex.ts        CODEX_PRESETS                │     │
│  │    └── claudecode.ts   CLAUDECODE_PRESETS           │     │
│  │                                                      │     │
│  │  paths.ts（环境感知的路径管理）                      │     │
│  │    - getCcmanDir()  根据 NODE_ENV 返回对应目录     │     │
│  │    - getCodexDir()                                  │     │
│  │    - getClaudeDir()                                 │     │
│  └──────────────────────────────────────────────────────┘     │
│                              ↓                                 │
│  ┌──────────────────────────────────────────────────────┐     │
│  │ Writers (外部集成 - Core 的内部模块)                 │     │
│  │                                                      │     │
│  │  writers/codex.ts                                   │     │
│  │    export function writeCodexConfig(provider)       │     │
│  │      → 读取 ~/.codex/config.toml                    │     │
│  │      → 更新 model_provider 和 model_providers       │     │
│  │      → 写入 ~/.codex/config.toml                    │     │
│  │      → 写入 ~/.codex/auth.json                      │     │
│  │                                                      │     │
│  │  writers/claudecode.ts                              │     │
│  │    export function writeClaudeCodeConfig(provider)  │     │
│  │      → 读取 ~/.claude/settings.json                 │     │
│  │      → 更新 ANTHROPIC_AUTH_TOKEN/BASE_URL           │     │
│  │      → 写入 ~/.claude/settings.json                 │     │
│  │                                                      │     │
│  │  特点：                                              │     │
│  │    ✅ 纯函数，不是类                                │     │
│  │    ✅ 单一职责：只负责写入外部工具配置               │     │
│  │    ✅ 零破坏性：读取-合并-写入模式                   │     │
│  │    ✅ 环境感知（根据 NODE_ENV 决定写入路径）        │     │
│  └──────────────────────────────────────────────────────┘     │
│                                                                │
│  说明：Writers 是 Core 的内部模块，位于                       │
│        packages/core/src/writers/                             │
└────────────────────────────────────────────────────────────────┘
```

### 2.2 项目目录结构

```
packages/
├── core/                    # Core Layer（核心业务层）
│   ├── src/
│   │   ├── tool-manager.ts  # 工厂函数，导出 codex 和 claudeCode
│   │   ├── types.ts         # 类型定义
│   │   ├── paths.ts         # 环境感知路径管理
│   │   │
│   │   ├── config/          # 配置文件读写（ccman 自己的数据）
│   │   │   ├── codex.ts
│   │   │   └── claudecode.ts
│   │   │
│   │   ├── presets/         # 预设服务商
│   │   │   ├── codex.ts
│   │   │   └── claudecode.ts
│   │   │
│   │   ├── writers/         # ⭐ Writers（Core 的内部模块）
│   │   │   ├── codex.ts     # 写入 ~/.codex/config.toml
│   │   │   └── claudecode.ts # 写入 ~/.claude/settings.json
│   │   │
│   │   └── utils/
│   │       ├── file.ts
│   │       └── validator.ts
│   └── package.json
│
├── cli/                     # CLI Layer（命令行界面）
│   ├── src/
│   │   ├── index.ts
│   │   ├── commands/
│   │   │   ├── codex.ts
│   │   │   ├── claudecode.ts
│   │   │   └── status.ts
│   │   └── utils/
│   └── package.json
│
└── desktop/                 # Desktop Layer（图形界面）
    ├── src/
    │   ├── main/            # Main Process
    │   │   ├── index.ts
    │   │   ├── ipc-handlers.ts  # 直接调用 Core
    │   │   └── window.ts
    │   ├── preload/         # Preload Script
    │   │   └── index.ts
    │   └── renderer/        # Renderer Process
    │       ├── App.tsx
    │       └── components/
    └── package.json
```

**重点说明**：
- **Writers 在 `packages/core/src/writers/` 目录下**
- Writers 是 Core 的内部模块，不是独立的 package
- CLI 和 Desktop 都调用 Core，Core 内部调用 Writers

### 2.3 数据流向图

#### CLI 数据流

```
用户输入
  ↓
ccman cx add
  ↓
CLI Layer (commands/codex.ts)
  ↓ 调用
codex.addProvider(input)
  ↓
Core Layer (tool-manager.ts)
  ├─→ 1. 保存到 ~/.ccman/codex.json
  └─→ 2. 调用 writeCodexConfig(provider)
        ↓
Writers Layer (writers/codex.ts)
  └─→ 写入 ~/.codex/config.toml + auth.json
```

#### Desktop 数据流

```
用户点击"添加 Codex 服务商"
  ↓
Renderer (CodexPanel.tsx)
  ├─→ 1. 显示 ProviderForm
  ├─→ 2. 调用 window.electronAPI.codex.getPresets()
  │     ↓ IPC
  │   Preload Script
  │     ↓ IPC
  │   Main Process → codex.getPresets()
  │     ↓ 返回
  │   显示预设列表
  │
  └─→ 3. 用户提交表单
      ↓ 调用 window.electronAPI.codex.addProvider(input)
        ↓ IPC
      Preload Script
        ↓ IPC
      Main Process
        ↓ 调用
      codex.addProvider(input)
        ↓
      Core Layer (tool-manager.ts)
        ├─→ 1. 保存到 ~/.ccman/codex.json
        └─→ 2. 调用 writeCodexConfig(provider)
              ↓
        Writers Layer (writers/codex.ts)
          └─→ 写入 ~/.codex/config.toml + auth.json
              ↓ 返回
        Renderer: 显示成功消息，刷新列表
```

### 2.4 Desktop 层详细设计（关注点分离）

#### 架构原则

Desktop 基于 Electron，采用**严格的三层关注点分离**：

```
┌─────────────────────────────────────────────────────────┐
│ Renderer Process (React)                                │
│ 关注点：UI 展示 + 用户交互                              │
│ 职责：                                                  │
│   ✅ UI 组件渲染                                        │
│   ✅ 用户交互处理（表单、按钮）                         │
│   ✅ 调用 window.electronAPI.*                          │
│   ❌ 不包含业务逻辑                                     │
│   ❌ 不能直接访问 Node.js API                           │
└─────────────────────────────────────────────────────────┘
                         ↓ IPC
┌─────────────────────────────────────────────────────────┐
│ Preload Script                                          │
│ 关注点：API 暴露（安全桥梁）                            │
│ 职责：                                                  │
│   ✅ contextBridge.exposeInMainWorld()                  │
│   ✅ 定义 electronAPI 接口                              │
│   ❌ 不包含任何逻辑                                     │
│   ❌ 只是 IPC 的薄封装                                  │
└─────────────────────────────────────────────────────────┘
                         ↓ IPC
┌─────────────────────────────────────────────────────────┐
│ Main Process (Node.js)                                  │
│ 关注点：IPC 处理 + 调用 Core                            │
│ 职责：                                                  │
│   ✅ ipcMain.handle() 注册 IPC 处理器                   │
│   ✅ 直接调用 Core API                                  │
│   ✅ 窗口管理、菜单管理                                 │
│   ❌ 不包含业务逻辑（和 CLI 一样）                      │
└─────────────────────────────────────────────────────────┘
                         ↓ import
┌─────────────────────────────────────────────────────────┐
│ Core Layer                                              │
│ 关注点：业务逻辑 + 数据管理                             │
│ 职责：所有业务逻辑都在这里                              │
└─────────────────────────────────────────────────────────┘
```

#### Desktop 目录结构

```
packages/desktop/
├── src/
│   ├── main/                    # Main Process（Node.js 环境）
│   │   ├── index.ts             # 应用入口
│   │   │   └── 职责：
│   │   │       - app.whenReady() 生命周期
│   │   │       - 创建窗口
│   │   │       - 注册 IPC handlers
│   │   │       - 应用退出处理
│   │   │
│   │   ├── window.ts            # 窗口管理
│   │   │   └── 职责：
│   │   │       - createMainWindow()
│   │   │       - BrowserWindow 配置
│   │   │       - 安全配置（contextIsolation, nodeIntegration）
│   │   │
│   │   ├── ipc-handlers.ts      # ⭐ IPC 处理器（核心）
│   │   │   └── 职责：
│   │   │       - 注册所有 ipcMain.handle()
│   │   │       - 直接调用 Core API（import { codex, claudeCode }）
│   │   │       - 错误处理
│   │   │       - 关注点：IPC 转发，不包含业务逻辑
│   │   │
│   │   ├── menu.ts              # 菜单管理（可选）
│   │   │   └── 职责：应用菜单、右键菜单
│   │   │
│   │   ├── tray.ts              # 系统托盘（可选）
│   │   │   └── 职责：托盘图标、托盘菜单
│   │   │
│   │   └── updater.ts           # 自动更新（可选）
│   │       └── 职责：检查更新、下载、安装
│   │
│   ├── preload/                 # Preload Script（安全桥梁）
│   │   ├── index.ts             # Preload 入口
│   │   │   └── 职责：
│   │   │       - contextBridge.exposeInMainWorld()
│   │   │       - 暴露 window.electronAPI
│   │   │       - 关注点：API 暴露，不包含逻辑
│   │   │
│   │   └── types.ts             # TypeScript 类型定义
│   │       └── 职责：定义 window.electronAPI 的类型
│   │
│   └── renderer/                # Renderer Process（浏览器环境）
│       ├── index.html           # HTML 入口
│       ├── index.tsx            # React 入口
│       │
│       ├── App.tsx              # ⭐ 应用主框架
│       │   └── 职责：
│       │       - 标签页切换（Codex / Claude Code）
│       │       - 全局布局
│       │       - 路由管理（如果需要）
│       │
│       ├── components/          # UI 组件
│       │   ├── CodexPanel.tsx
│       │   │   └── 职责：
│       │   │       - 显示 Codex 服务商列表
│       │   │       - 显示当前激活的服务商
│       │   │       - 处理用户交互（添加、切换、编辑、删除）
│       │   │       - 调用 window.electronAPI.codex.*
│       │   │       - 关注点：UI 展示，不包含业务逻辑
│       │   │
│       │   ├── ClaudeCodePanel.tsx
│       │   │   └── 职责：同 CodexPanel，但操作 claudeCode
│       │   │
│       │   ├── ProviderList.tsx
│       │   │   └── 职责：
│       │   │       - 通用的服务商列表组件
│       │   │       - Props: providers, currentProvider
│       │   │       - 回调: onSwitch, onEdit, onRemove
│       │   │       - 可复用（Codex 和 Claude Code 都用）
│       │   │
│       │   ├── ProviderForm.tsx
│       │   │   └── 职责：
│       │   │       - 添加/编辑服务商的表单
│       │   │       - 支持预设选择 or 自定义配置
│       │   │       - 表单验证（URL 格式、必填项）
│       │   │       - 提交时触发回调
│       │   │
│       │   ├── StatusBar.tsx
│       │   │   └── 职责：
│       │   │       - 底部状态栏
│       │   │       - 显示两个工具的当前状态
│       │   │       - 显示配置文件路径
│       │   │
│       │   └── Header.tsx
│       │       └── 职责：顶部标题栏、Logo
│       │
│       ├── hooks/               # React Hooks
│       │   ├── useCodexProviders.ts
│       │   │   └── 职责：
│       │   │       - 封装 Codex 数据获取和操作逻辑
│       │   │       - 调用 window.electronAPI.codex.*
│       │   │       - 管理 loading/error 状态
│       │   │       - 关注点：数据逻辑封装，不包含 UI
│       │   │
│       │   └── useClaudeCodeProviders.ts
│       │       └── 职责：同 useCodexProviders
│       │
│       ├── styles/              # 样式文件
│       │   ├── global.css
│       │   └── components.css
│       │
│       └── types/               # TypeScript 类型
│           └── electron.d.ts    # 扩展 window.electronAPI 类型
│
├── package.json
├── tsconfig.json
├── vite.config.ts               # Vite 配置（Renderer 打包）
└── electron-builder.yml         # Electron 打包配置
```

#### 关注点分离示例

**✅ 正确示例 - Renderer 只管 UI**

```typescript
// renderer/components/CodexPanel.tsx
import { useCodexProviders } from '../hooks/useCodexProviders'

export function CodexPanel() {
  // ✅ 使用 Hook 获取数据和操作方法
  const { providers, current, addProvider, switchProvider, loading } = useCodexProviders()

  // ✅ UI 交互处理
  const handleAdd = async (input) => {
    await addProvider(input)  // ✅ 调用 Hook 方法
    alert('添加成功')          // ✅ UI 反馈
  }

  // ✅ 只管 UI 渲染
  return (
    <div>
      <h2>Codex 服务商</h2>
      {current && <div>当前：{current.name}</div>}
      <ProviderList
        providers={providers}
        currentProvider={current}
        onSwitch={switchProvider}
      />
      <button onClick={() => setShowForm(true)}>添加</button>
    </div>
  )
}
```

**✅ 正确示例 - Hook 封装数据逻辑**

```typescript
// renderer/hooks/useCodexProviders.ts
export function useCodexProviders() {
  const [providers, setProviders] = useState([])
  const [current, setCurrent] = useState(null)
  const [loading, setLoading] = useState(false)

  // ✅ 封装数据获取
  const loadProviders = async () => {
    setLoading(true)
    const data = await window.electronAPI.codex.listProviders()
    setProviders(data)
    setLoading(false)
  }

  const loadCurrent = async () => {
    const data = await window.electronAPI.codex.getCurrent()
    setCurrent(data)
  }

  // ✅ 封装数据操作
  const addProvider = async (input) => {
    const provider = await window.electronAPI.codex.addProvider(input)
    await loadProviders()  // 刷新列表
    return provider
  }

  const switchProvider = async (id) => {
    await window.electronAPI.codex.switchProvider(id)
    await loadCurrent()  // 刷新当前
  }

  useEffect(() => {
    loadProviders()
    loadCurrent()
  }, [])

  return { providers, current, addProvider, switchProvider, loading }
}
```

**✅ 正确示例 - Main Process 只转发 IPC**

```typescript
// main/ipc-handlers.ts
import { ipcMain } from 'electron'
import { codex, claudeCode } from '@ccman/core'

export function registerIpcHandlers() {
  // ✅ 只转发 IPC，不包含业务逻辑
  ipcMain.handle('codex-add-provider', async (event, input) => {
    try {
      return codex.addProvider(input)  // ✅ 直接调用 Core
    } catch (error) {
      console.error('[Main] codex-add-provider error:', error)
      throw error  // ✅ 重新抛出，让 Renderer 处理
    }
  })

  ipcMain.handle('codex-list-providers', async () => {
    return codex.listProviders()  // ✅ 直接调用 Core
  })

  ipcMain.handle('codex-switch-provider', async (event, id) => {
    codex.switchProvider(id)  // ✅ 直接调用 Core
  })

  // ... 其他 IPC handlers
}
```

**❌ 错误示例 - Renderer 包含业务逻辑**

```typescript
// ❌ 不要这样做
export function CodexPanel() {
  const handleAdd = (input) => {
    // ❌ 在 Renderer 中生成 ID
    const id = `codex-${Date.now()}-${Math.random()}`

    // ❌ 在 Renderer 中创建 Provider
    const provider = {
      id,
      name: input.name,
      baseUrl: input.baseUrl,
      apiKey: input.apiKey,
      createdAt: Date.now(),
    }

    // ❌ 在 Renderer 中做验证
    if (!provider.baseUrl.startsWith('http')) {
      alert('Invalid URL')
      return
    }

    window.electronAPI.codex.saveProvider(provider)
  }
}
```

#### Desktop 和 CLI 的对比

| 层级 | CLI | Desktop | 职责 |
|------|-----|---------|------|
| **用户交互** | inquirer | React UI | 获取用户输入 |
| **中间层** | 无 | Preload Script | CLI 直接调用，Desktop 需要 IPC |
| **业务调用** | commands/*.ts | Main Process | 调用 Core API |
| **业务逻辑** | Core | Core | 完全相同！ |

**关键点**：
- CLI 和 Desktop Main Process 的代码**几乎一样**
- 区别只在于：
  - CLI: 直接调用 Core
  - Main: 通过 IPC 接收请求，然后调用 Core
- 业务逻辑**100% 在 Core 中**，两者都不包含业务逻辑

---

## 三、命令结构设计

### 3.1 完整命令列表

```bash
# ========== Codex 操作 ==========
ccman cx add               # 添加 Codex 服务商
ccman cx list              # 列出 Codex 服务商
ccman cx use <name|id>     # 切换 Codex 服务商
ccman cx current           # 查看 Codex 当前服务商
ccman cx edit <name|id>    # 编辑 Codex 服务商
ccman cx remove <name|id>  # 删除 Codex 服务商
ccman cx init              # 初始化 Codex（选择预设）

# ========== Claude Code 操作 ==========
ccman cc add               # 添加 Claude Code 服务商
ccman cc list              # 列出 Claude Code 服务商
ccman cc use <name|id>     # 切换 Claude Code 服务商
ccman cc current           # 查看 Claude Code 当前服务商
ccman cc edit <name|id>    # 编辑 Claude Code 服务商
ccman cc remove <name|id>  # 删除 Claude Code 服务商
ccman cc init              # 初始化 Claude Code（选择预设）

# ========== 全局命令 ==========
ccman status               # 查看两个工具的当前状态
ccman version              # 版本信息
ccman help                 # 帮助信息
```

### 3.2 命令交互示例

```bash
$ ccman cc add

📝 添加 Claude Code 服务商

? 选择配置来源：
  ❯ 📦 使用预置服务商
    ✏️  自定义配置

? 选择预置服务商：
  ❯ Anthropic Official - Anthropic 官方 API
    AnyRouter - AnyRouter API 服务
    PackyCode - PackyCode API 服务

? 输入 API 密钥： ********

✅ 添加成功

  Anthropic Official [Claude Code]
  ID: claudecode-1234567890-abc123
  URL: https://api.anthropic.com

? 是否立即切换到此服务商？ Yes

✅ 已切换到新服务商
配置已更新：~/.claude/settings.json
```

```bash
$ ccman status

📊 当前状态

┌─────────────────────────────────────────────┐
│ Codex                                       │
│   ● OpenAI                                  │
│   URL: https://api.openai.com               │
│   配置: ~/.codex/config.toml                │
└─────────────────────────────────────────────┘

┌─────────────────────────────────────────────┐
│ Claude Code                                 │
│   ● Anthropic Official                      │
│   URL: https://api.anthropic.com            │
│   配置: ~/.claude/settings.json             │
└─────────────────────────────────────────────┘
```

---

## 四、数据结构设计

### 4.1 类型定义

```typescript
// packages/core/src/types.ts

/**
 * 工具类型
 * - codex: Codex
 * - claudecode: Claude Code（注意：不是 claude！）
 */
export type ToolType = 'codex' | 'claudecode'

/**
 * 服务商配置
 * 注意：不再需要 type 字段，因为配置文件已经分离
 */
export interface Provider {
  /** 唯一标识符（自动生成，格式：{tool}-{timestamp}-{random}） */
  id: string
  /** 显示名称 */
  name: string
  /** API Base URL */
  baseUrl: string
  /** API Key */
  apiKey: string
  /** 创建时间（Unix timestamp） */
  createdAt: number
  /** 最后使用时间（Unix timestamp，可选） */
  lastUsedAt?: number
}

/**
 * 单个工具的配置文件结构
 */
export interface ToolConfig {
  /** 服务商列表 */
  providers: Provider[]
  /** 当前激活的服务商 ID */
  activeProviderId?: string
}

/**
 * 预设模板（不包含 API Key）
 */
export interface PresetTemplate {
  /** 预设名称 */
  name: string
  /** 默认 Base URL */
  baseUrl: string
  /** 描述 */
  description: string
}

/**
 * 添加服务商的输入参数
 */
export interface AddProviderInput {
  name: string
  baseUrl: string
  apiKey: string
}

/**
 * 编辑服务商的输入参数
 */
export interface EditProviderInput {
  name?: string
  baseUrl?: string
  apiKey?: string
}
```

### 4.2 配置文件格式

#### Codex 配置文件（`~/.ccman/codex.json`）

```json
{
  "providers": [
    {
      "id": "codex-1704614400000-a1b2c3",
      "name": "OpenAI",
      "baseUrl": "https://api.openai.com",
      "apiKey": "sk-xxx",
      "createdAt": 1704614400000,
      "lastUsedAt": 1704614500000
    },
    {
      "id": "codex-1704614500000-d4e5f6",
      "name": "Anthropic",
      "baseUrl": "https://api.anthropic.com",
      "apiKey": "sk-ant-yyy",
      "createdAt": 1704614500000
    }
  ],
  "activeProviderId": "codex-1704614400000-a1b2c3"
}
```

#### Claude Code 配置文件（`~/.ccman/claudecode.json`）

```json
{
  "providers": [
    {
      "id": "claudecode-1704614600000-g7h8i9",
      "name": "Anthropic Official",
      "baseUrl": "https://api.anthropic.com",
      "apiKey": "sk-ant-zzz",
      "createdAt": 1704614600000,
      "lastUsedAt": 1704614700000
    },
    {
      "id": "claudecode-1704614700000-j1k2l3",
      "name": "AnyRouter",
      "baseUrl": "https://anyrouter.top",
      "apiKey": "sk-or-www",
      "createdAt": 1704614700000
    }
  ],
  "activeProviderId": "claudecode-1704614600000-g7h8i9"
}
```

---

## 五、环境配置方案

### 5.1 环境类型

```typescript
type Environment = 'production' | 'development' | 'test'
```

| 环境 | NODE_ENV | 说明 | 用途 |
|------|----------|------|------|
| **生产环境** | `production`（默认） | 正式使用 | 用户日常使用 |
| **开发环境** | `development` | 开发调试 | CLI/Desktop 手动测试 |
| **测试环境** | `test` | 自动化测试 | 单元测试、集成测试 |

### 5.2 环境配置表

#### 生产环境（`production`）

| 配置类型 | 路径 | 说明 |
|---------|------|------|
| ccman 配置 | `~/.ccman/codex.json` | Codex 服务商列表 |
| | `~/.ccman/claudecode.json` | Claude Code 服务商列表 |
| Codex 配置 | `~/.codex/config.toml` | Codex 工具配置 |
| | `~/.codex/auth.json` | Codex API Key |
| Claude 配置 | `~/.claude/settings.json` | Claude Code 工具配置 |

#### 开发环境（`development`）

| 配置类型 | 路径 | 说明 |
|---------|------|------|
| ccman 配置 | `$TMPDIR/ccman-dev/.ccman/codex.json` | 开发环境 Codex 配置 |
| | `$TMPDIR/ccman-dev/.ccman/claudecode.json` | 开发环境 Claude Code 配置 |
| Codex 配置 | `$TMPDIR/ccman-dev/.codex/config.toml` | 开发环境 Codex 工具配置 |
| | `$TMPDIR/ccman-dev/.codex/auth.json` | 开发环境 Codex API Key |
| Claude 配置 | `$TMPDIR/ccman-dev/.claude/settings.json` | 开发环境 Claude Code 配置 |

**说明**：
- `$TMPDIR` 在 macOS 上通常是 `/var/folders/...`
- 开发环境使用独立目录，**不影响正式环境**
- 可以通过 `rm -rf $TMPDIR/ccman-dev` 清理开发数据

#### 测试环境（`test`）

| 配置类型 | 路径 | 说明 |
|---------|------|------|
| ccman 配置 | `$TMPDIR/ccman-test-{PID}/.ccman/codex.json` | 测试环境 Codex 配置 |
| | `$TMPDIR/ccman-test-{PID}/.ccman/claudecode.json` | 测试环境 Claude Code 配置 |
| Codex 配置 | `$TMPDIR/ccman-test-{PID}/.codex/config.toml` | 测试环境 Codex 配置 |
| | `$TMPDIR/ccman-test-{PID}/.codex/auth.json` | 测试环境 Codex API Key |
| Claude 配置 | `$TMPDIR/ccman-test-{PID}/.claude/settings.json` | 测试环境 Claude Code 配置 |

**说明**：
- 每个测试进程使用独立目录（基于 PID）
- 测试结束后自动清理（可选）
- **绝不影响正式环境**

### 5.3 环境切换方式

#### 方式 1：通过 NODE_ENV 环境变量

```bash
# 生产环境（默认）
ccman cx add

# 开发环境
NODE_ENV=development ccman cx add

# 测试环境（仅限自动化测试）
NODE_ENV=test pnpm test
```

#### 方式 2：通过 package.json 脚本

```json
{
  "scripts": {
    "dev": "NODE_ENV=development node packages/cli/dist/index.js",
    "test": "NODE_ENV=test vitest",
    "start": "NODE_ENV=production node packages/cli/dist/index.js"
  }
}
```

使用：
```bash
pnpm dev cx add        # 开发环境
pnpm test              # 测试环境
pnpm start cx add      # 生产环境
```

### 5.4 路径管理实现

```typescript
// packages/core/src/paths.ts

import os from 'os'
import path from 'path'

/**
 * 获取当前环境类型
 */
function getEnvironment(): 'production' | 'development' | 'test' {
  const env = process.env.NODE_ENV || 'production'

  if (env === 'test') return 'test'
  if (env === 'development') return 'development'
  return 'production'
}

/**
 * 获取环境根目录
 */
function getEnvRoot(): string {
  const env = getEnvironment()

  switch (env) {
    case 'production':
      // 生产环境：用户主目录
      return os.homedir()

    case 'development':
      // 开发环境：临时目录/ccman-dev
      return path.join(os.tmpdir(), 'ccman-dev')

    case 'test':
      // 测试环境：临时目录/ccman-test-{PID}
      return path.join(os.tmpdir(), `ccman-test-${process.pid}`)
  }
}

/**
 * 获取 ccman 配置目录
 * - production: ~/.ccman
 * - development: $TMPDIR/ccman-dev/.ccman
 * - test: $TMPDIR/ccman-test-{PID}/.ccman
 */
export function getCcmanDir(): string {
  return path.join(getEnvRoot(), '.ccman')
}

/**
 * 获取 Codex 配置目录
 * - production: ~/.codex
 * - development: $TMPDIR/ccman-dev/.codex
 * - test: $TMPDIR/ccman-test-{PID}/.codex
 */
export function getCodexDir(): string {
  return path.join(getEnvRoot(), '.codex')
}

/**
 * 获取 Claude Code 配置目录
 * - production: ~/.claude
 * - development: $TMPDIR/ccman-dev/.claude
 * - test: $TMPDIR/ccman-test-{PID}/.claude
 */
export function getClaudeDir(): string {
  return path.join(getEnvRoot(), '.claude')
}

/**
 * 获取 Codex 配置文件路径
 */
export function getCodexConfigPath(): string {
  return path.join(getCcmanDir(), 'codex.json')
}

/**
 * 获取 Claude Code 配置文件路径
 */
export function getClaudeCodeConfigPath(): string {
  return path.join(getCcmanDir(), 'claudecode.json')
}

/**
 * 清理测试环境目录（仅测试环境可用）
 */
export function cleanupTestEnv(): void {
  const env = getEnvironment()

  if (env !== 'test') {
    throw new Error('cleanupTestEnv() can only be called in test environment')
  }

  const testRoot = getEnvRoot()
  const fs = require('fs')

  if (fs.existsSync(testRoot)) {
    fs.rmSync(testRoot, { recursive: true, force: true })
  }
}

/**
 * 打印当前环境信息（调试用）
 */
export function printEnvInfo(): void {
  console.log('Environment:', getEnvironment())
  console.log('ccman dir:', getCcmanDir())
  console.log('Codex dir:', getCodexDir())
  console.log('Claude dir:', getClaudeDir())
}
```

### 5.5 环境安全检查

```typescript
// packages/core/src/utils/env-check.ts

import { getEnvironment, getCcmanDir } from '../paths'
import os from 'os'

/**
 * 检查是否在安全的环境中执行危险操作
 */
export function checkSafeToModify(): void {
  const env = getEnvironment()
  const ccmanDir = getCcmanDir()
  const homeDir = os.homedir()

  // 如果在生产环境，且配置目录是主目录下的 .ccman
  if (env === 'production' && ccmanDir === `${homeDir}/.ccman`) {
    // 生产环境，允许修改
    return
  }

  // 如果在开发/测试环境，且配置目录不是主目录下的
  if (env !== 'production' && !ccmanDir.startsWith(homeDir)) {
    // 开发/测试环境，允许修改
    return
  }

  // 其他情况，抛出错误
  throw new Error(
    `Unsafe environment detected!\n` +
    `Environment: ${env}\n` +
    `Config dir: ${ccmanDir}\n` +
    `This may modify production files. Please check NODE_ENV.`
  )
}

/**
 * 防止在测试中误删生产环境文件
 */
export function preventProductionModification(): void {
  const env = getEnvironment()
  const ccmanDir = getCcmanDir()
  const homeDir = os.homedir()

  // 如果配置目录指向主目录，但环境不是 production
  if (ccmanDir.startsWith(homeDir) && env !== 'production') {
    throw new Error(
      `❌ DANGER: Config directory points to home directory in ${env} environment!\n` +
      `This would modify production files.\n` +
      `Config dir: ${ccmanDir}\n` +
      `Environment: ${env}\n\n` +
      `Fix: Set NODE_ENV=${env} correctly.`
    )
  }
}
```

### 5.6 开发环境测试流程

#### 清理开发环境数据

```bash
# 查看开发环境路径
NODE_ENV=development node -e "console.log(require('os').tmpdir() + '/ccman-dev')"

# 清理开发环境数据
rm -rf $(node -e "console.log(require('os').tmpdir())")/ccman-dev

# 或者使用脚本
pnpm clean:dev
```

#### 手动测试

```bash
# 1. 清理开发环境
rm -rf $TMPDIR/ccman-dev

# 2. 运行 CLI（开发环境）
NODE_ENV=development pnpm dev cx add

# 3. 查看生成的配置
cat $TMPDIR/ccman-dev/.ccman/codex.json
cat $TMPDIR/ccman-dev/.codex/config.toml

# 4. 确认不影响生产环境
cat ~/.ccman/codex.json  # 不应该被修改
```

---

## 六、模块详细设计

### 6.1 Core Layer - tool-manager.ts

```typescript
// packages/core/src/tool-manager.ts

import { ToolType, Provider, AddProviderInput, EditProviderInput, ToolConfig } from './types'
import { getCodexConfigPath, getClaudeCodeConfigPath } from './paths'
import { readJSON, writeJSON, fileExists, ensureDir } from './utils/file'
import { writeCodexConfig } from './writers/codex'
import { writeClaudeCodeConfig } from './writers/claudecode'
import { CODEX_PRESETS } from './presets/codex'
import { CLAUDECODE_PRESETS } from './presets/claudecode'
import path from 'path'

/**
 * 工具管理器接口
 */
export interface ToolManager {
  addProvider(input: AddProviderInput): Provider
  listProviders(): Provider[]
  getProvider(id: string): Provider
  switchProvider(id: string): void
  getCurrentProvider(): Provider | null
  updateProvider(id: string, updates: EditProviderInput): Provider
  removeProvider(id: string): void
  getPresets(): PresetTemplate[]
}

/**
 * 创建工具管理器（工厂函数）
 */
function createToolManager(tool: ToolType): ToolManager {
  // 配置文件路径
  const configPath = tool === 'codex'
    ? getCodexConfigPath()
    : getClaudeCodeConfigPath()

  // 预设服务商
  const presets = tool === 'codex' ? CODEX_PRESETS : CLAUDECODE_PRESETS

  // 加载配置
  function loadConfig(): ToolConfig {
    if (!fileExists(configPath)) {
      const emptyConfig: ToolConfig = {
        providers: [],
        activeProviderId: undefined,
      }
      ensureDir(path.dirname(configPath))
      writeJSON(configPath, emptyConfig)
      return emptyConfig
    }

    return readJSON<ToolConfig>(configPath)
  }

  // 保存配置
  function saveConfig(config: ToolConfig): void {
    writeJSON(configPath, config)
  }

  // 生成唯一 ID
  function generateId(): string {
    const timestamp = Date.now()
    const random = Math.random().toString(36).substring(2, 8)
    return `${tool}-${timestamp}-${random}`
  }

  return {
    // 添加服务商
    addProvider(input: AddProviderInput): Provider {
      const config = loadConfig()

      const provider: Provider = {
        id: generateId(),
        name: input.name,
        baseUrl: input.baseUrl,
        apiKey: input.apiKey,
        createdAt: Date.now(),
      }

      config.providers.push(provider)
      saveConfig(config)

      return provider
    },

    // 列出所有服务商
    listProviders(): Provider[] {
      const config = loadConfig()
      return config.providers
    },

    // 获取服务商
    getProvider(id: string): Provider {
      const config = loadConfig()
      const provider = config.providers.find(p => p.id === id)

      if (!provider) {
        throw new Error(`Provider not found: ${id}`)
      }

      return provider
    },

    // 切换服务商
    switchProvider(id: string): void {
      const config = loadConfig()
      const provider = config.providers.find(p => p.id === id)

      if (!provider) {
        throw new Error(`Provider not found: ${id}`)
      }

      config.activeProviderId = id
      provider.lastUsedAt = Date.now()
      saveConfig(config)

      // 写入目标工具配置（调用 writer 函数）
      if (tool === 'codex') {
        writeCodexConfig(provider)
      } else if (tool === 'claudecode') {
        writeClaudeCodeConfig(provider)
      }
    },

    // 获取当前服务商
    getCurrentProvider(): Provider | null {
      const config = loadConfig()

      if (!config.activeProviderId) {
        return null
      }

      return config.providers.find(p => p.id === config.activeProviderId) || null
    },

    // 更新服务商
    updateProvider(id: string, updates: EditProviderInput): Provider {
      const config = loadConfig()
      const provider = config.providers.find(p => p.id === id)

      if (!provider) {
        throw new Error(`Provider not found: ${id}`)
      }

      // 更新字段
      if (updates.name !== undefined) provider.name = updates.name
      if (updates.baseUrl !== undefined) provider.baseUrl = updates.baseUrl
      if (updates.apiKey !== undefined) provider.apiKey = updates.apiKey

      saveConfig(config)

      // 如果是当前激活的服务商，重新写入配置
      if (config.activeProviderId === id) {
        if (tool === 'codex') {
          writeCodexConfig(provider)
        } else if (tool === 'claudecode') {
          writeClaudeCodeConfig(provider)
        }
      }

      return provider
    },

    // 删除服务商
    removeProvider(id: string): void {
      const config = loadConfig()
      const index = config.providers.findIndex(p => p.id === id)

      if (index === -1) {
        throw new Error(`Provider not found: ${id}`)
      }

      // 如果删除的是当前服务商，清除激活状态
      if (config.activeProviderId === id) {
        config.activeProviderId = undefined
      }

      config.providers.splice(index, 1)
      saveConfig(config)
    },

    // 获取预设服务商
    getPresets() {
      return presets
    }
  }
}

// 导出两个实例
export const codex = createToolManager('codex')
export const claudeCode = createToolManager('claudecode')
```

### 6.2 Writers Layer - codex.ts

```typescript
// packages/core/src/writers/codex.ts

import { Provider } from '../types'
import { getCodexDir } from '../paths'
import { ensureDir, fileExists } from '../utils/file'
import path from 'path'
import fs from 'fs'
import TOML from '@iarna/toml'

/**
 * 写入 Codex 配置文件
 *
 * 目标文件：
 * - ~/.codex/config.toml
 * - ~/.codex/auth.json
 */
export function writeCodexConfig(provider: Provider): void {
  const codexDir = getCodexDir()
  ensureDir(codexDir)

  const configPath = path.join(codexDir, 'config.toml')
  const authPath = path.join(codexDir, 'auth.json')

  // 1. 写入 config.toml
  writeConfigToml(configPath, provider)

  // 2. 写入 auth.json
  writeAuthJson(authPath, provider)
}

/**
 * 写入 config.toml
 */
function writeConfigToml(configPath: string, provider: Provider): void {
  let config: any

  // 读取现有配置（如果存在）
  if (fileExists(configPath)) {
    const content = fs.readFileSync(configPath, 'utf-8')
    config = TOML.parse(content)
  } else {
    config = {}
  }

  // 更新配置（零破坏性）
  config.model_provider = provider.name

  if (!config.model_providers) {
    config.model_providers = {}
  }

  config.model_providers[provider.name] = {
    name: provider.name,
    base_url: provider.baseUrl,
    wire_api: 'responses',
    requires_openai_auth: true,
  }

  // 写入文件
  const tomlString = TOML.stringify(config)
  fs.writeFileSync(configPath, tomlString, 'utf-8')
}

/**
 * 写入 auth.json
 */
function writeAuthJson(authPath: string, provider: Provider): void {
  const auth = {
    OPENAI_API_KEY: provider.apiKey,
  }

  fs.writeFileSync(authPath, JSON.stringify(auth, null, 2), 'utf-8')
}
```

### 6.3 Writers Layer - claudecode.ts

```typescript
// packages/core/src/writers/claudecode.ts

import { Provider } from '../types'
import { getClaudeDir } from '../paths'
import { ensureDir, fileExists, readJSON, writeJSON } from '../utils/file'
import path from 'path'

/**
 * 写入 Claude Code 配置文件
 *
 * 目标文件：
 * - ~/.claude/settings.json
 */
export function writeClaudeCodeConfig(provider: Provider): void {
  const claudeDir = getClaudeDir()
  ensureDir(claudeDir)

  const settingsPath = path.join(claudeDir, 'settings.json')

  let settings: any

  // 读取现有配置（如果存在）
  if (fileExists(settingsPath)) {
    settings = readJSON(settingsPath)
  } else {
    settings = {
      env: {},
      permissions: {
        allow: [],
        deny: [],
      },
    }
  }

  // 更新配置（零破坏性）
  if (!settings.env) {
    settings.env = {}
  }

  settings.env.ANTHROPIC_AUTH_TOKEN = provider.apiKey
  settings.env.ANTHROPIC_BASE_URL = provider.baseUrl

  // 写入文件
  writeJSON(settingsPath, settings)
}
```

### 6.4 Presets - codex.ts

```typescript
// packages/core/src/presets/codex.ts

import { PresetTemplate } from '../types'

export const CODEX_PRESETS: PresetTemplate[] = [
  {
    name: 'Anthropic Official',
    baseUrl: 'https://api.anthropic.com',
    description: 'Anthropic 官方 API',
  },
  {
    name: 'AnyRouter',
    baseUrl: 'https://anyrouter.top',
    description: 'AnyRouter API 服务',
  },
  {
    name: 'PackyCode',
    baseUrl: 'https://api.packycode.com',
    description: 'PackyCode API 服务',
  },
  {
    name: 'CoordCode',
    baseUrl: 'https://api.coordcode.com/api',
    description: 'CoordCode API 服务',
  },
  {
    name: '88Code',
    baseUrl: 'https://www.88code.org/api',
    description: '88Code API 服务',
  },
  {
    name: 'BigModel',
    baseUrl: 'https://open.bigmodel.cn/api/anthropic',
    description: '智谱 BigModel API',
  },
  {
    name: 'ModelScope',
    baseUrl: 'https://api-inference.modelscope.cn/v1/chat/completions',
    description: '阿里云 ModelScope API',
  },
]
```

### 6.5 Presets - claudecode.ts

```typescript
// packages/core/src/presets/claudecode.ts

import { PresetTemplate } from '../types'

export const CLAUDECODE_PRESETS: PresetTemplate[] = [
  {
    name: 'Anthropic Official',
    baseUrl: 'https://api.anthropic.com',
    description: 'Anthropic 官方 API',
  },
  {
    name: 'AnyRouter',
    baseUrl: 'https://anyrouter.top',
    description: 'AnyRouter API 服务',
  },
  {
    name: 'PackyCode',
    baseUrl: 'https://api.packycode.com',
    description: 'PackyCode API 服务',
  },
  {
    name: 'CoordCode',
    baseUrl: 'https://api.coordcode.com/api',
    description: 'CoordCode API 服务',
  },
  {
    name: '88Code',
    baseUrl: 'https://www.88code.org/api',
    description: '88Code API 服务',
  },
  {
    name: 'BigModel',
    baseUrl: 'https://open.bigmodel.cn/api/anthropic',
    description: '智谱 BigModel API',
  },
  {
    name: 'ModelScope',
    baseUrl: 'https://api-inference.modelscope.cn/v1/chat/completions',
    description: '阿里云 ModelScope API',
  },
]
```

---

## 七、工作流程

### 7.1 添加服务商流程

```
用户执行: ccman cx add
  ↓
CLI Layer (commands/codex.ts)
  ├─→ 1. 询问配置来源（预设 or 自定义）
  ├─→ 2. 如果选择预设：
  │      ├─→ 调用 codex.getPresets()
  │      ├─→ 显示预设列表（只显示 Codex 的预设）
  │      └─→ 选择预设 + 输入 API Key
  └─→ 3. 调用 codex.addProvider(input)
        ↓
Core Layer (tool-manager.ts)
  ├─→ 1. 生成唯一 ID
  ├─→ 2. 创建 Provider 对象
  ├─→ 3. 保存到 ~/.ccman/codex.json
  └─→ 4. 返回 Provider
        ↓
CLI Layer
  ├─→ 1. 显示添加成功信息
  ├─→ 2. 询问是否立即切换
  └─→ 3. 如果确认：调用 codex.switchProvider(id)
        ↓
Core Layer (tool-manager.ts)
  ├─→ 1. 更新 activeProviderId
  ├─→ 2. 更新 lastUsedAt
  ├─→ 3. 保存配置
  └─→ 4. 调用 writeCodexConfig(provider)
        ↓
Writers Layer (writers/codex.ts)
  ├─→ 1. 读取 ~/.codex/config.toml（如果存在）
  ├─→ 2. 更新 model_provider 和 model_providers
  ├─→ 3. 写入 ~/.codex/config.toml
  └─→ 4. 写入 ~/.codex/auth.json
```

### 7.2 切换服务商流程

```
用户执行: ccman cx use "OpenAI"
  ↓
CLI Layer (commands/codex.ts)
  ├─→ 1. 调用 codex.listProviders()
  ├─→ 2. 根据 name 查找 Provider
  └─→ 3. 调用 codex.switchProvider(id)
        ↓
Core Layer (tool-manager.ts)
  ├─→ 1. 更新 activeProviderId
  ├─→ 2. 更新 lastUsedAt
  ├─→ 3. 保存到 ~/.ccman/codex.json
  └─→ 4. 调用 writeCodexConfig(provider)
        ↓
Writers Layer (writers/codex.ts)
  ├─→ 1. 读取 ~/.codex/config.toml
  ├─→ 2. 更新 model_provider = "OpenAI"
  ├─→ 3. 更新 model_providers["OpenAI"]
  ├─→ 4. 写入 ~/.codex/config.toml
  └─→ 5. 写入 ~/.codex/auth.json
        ↓
CLI Layer
  └─→ 显示切换成功信息
```

### 7.3 查看状态流程

```
用户执行: ccman status
  ↓
CLI Layer (commands/status.ts)
  ├─→ 1. 调用 codex.getCurrentProvider()
  ├─→ 2. 调用 claudeCode.getCurrentProvider()
  └─→ 3. 格式化显示两者的状态
```

---

## 八、代码示例

### 8.1 CLI Layer - commands/codex.ts

```typescript
// packages/cli/src/commands/codex.ts

import { Command } from 'commander'
import { codex } from '@ccman/core'
import inquirer from 'inquirer'
import chalk from 'chalk'

export function codexCommand(program: Command): void {
  const codexCmd = program
    .command('cx')
    .description('管理 Codex 服务商')

  // ccman cx add
  codexCmd
    .command('add')
    .description('添加 Codex 服务商')
    .action(async () => {
      console.log(chalk.bold('\n📝 添加 Codex 服务商\n'))

      const { usePreset } = await inquirer.prompt([{
        type: 'list',
        name: 'usePreset',
        message: '选择配置来源：',
        choices: [
          { name: '📦 使用预置服务商', value: true },
          { name: '✏️  自定义配置', value: false },
        ],
      }])

      let input

      if (usePreset) {
        const presets = codex.getPresets()

        const { presetName } = await inquirer.prompt([{
          type: 'list',
          name: 'presetName',
          message: '选择预置服务商：',
          choices: presets.map(p => ({
            name: `${p.name} - ${p.description}`,
            value: p.name,
          })),
        }])

        const preset = presets.find(p => p.name === presetName)!
        const { apiKey } = await inquirer.prompt([{
          type: 'password',
          name: 'apiKey',
          message: '输入 API 密钥：',
          mask: '*',
        }])

        input = {
          name: preset.name,
          baseUrl: preset.baseUrl,
          apiKey,
        }
      } else {
        // 自定义配置...
      }

      const provider = codex.addProvider(input)

      console.log(chalk.green('\n✅ 添加成功\n'))
      console.log(`  ${chalk.bold(provider.name)} ${chalk.blue('[Codex]')}`)
      console.log(`  ${chalk.gray(`ID: ${provider.id}`)}`)
      console.log(`  ${chalk.gray(`URL: ${provider.baseUrl}`)}`)

      // 询问是否立即切换
      const { switchNow } = await inquirer.prompt([{
        type: 'confirm',
        name: 'switchNow',
        message: '是否立即切换到此服务商？',
        default: true,
      }])

      if (switchNow) {
        codex.switchProvider(provider.id)
        console.log(chalk.green('\n✅ 已切换到新服务商'))
        console.log(chalk.gray('配置已更新：~/.codex/config.toml'))
      }
    })

  // ccman cx list
  codexCmd
    .command('list')
    .alias('ls')
    .description('列出 Codex 服务商')
    .action(() => {
      const providers = codex.listProviders()
      const current = codex.getCurrentProvider()

      if (providers.length === 0) {
        console.log(chalk.yellow('\n⚠️  暂无服务商'))
        console.log(chalk.blue('💡 添加服务商：ccman cx add\n'))
        return
      }

      console.log(chalk.bold('\n📋 Codex 服务商列表：\n'))

      providers.forEach(provider => {
        const isCurrent = current?.id === provider.id
        const prefix = isCurrent ? chalk.green('● ') : '  '
        const name = isCurrent ? chalk.green.bold(provider.name) : chalk.white(provider.name)

        console.log(`${prefix}${name}`)
        console.log(`  ${chalk.gray(`ID: ${provider.id}`)}`)
        console.log(`  ${chalk.gray(`URL: ${provider.baseUrl}`)}`)

        if (isCurrent) {
          console.log(`  ${chalk.green('✓ 激活中')}`)
        }

        console.log()
      })

      console.log(chalk.gray(`共 ${providers.length} 个服务商\n`))
    })

  // ccman cx use
  codexCmd
    .command('use <name>')
    .description('切换 Codex 服务商')
    .action((name: string) => {
      const providers = codex.listProviders()
      const provider = providers.find(p => p.name === name || p.id === name)

      if (!provider) {
        console.error(chalk.red(`\n❌ 服务商不存在: ${name}\n`))
        console.log(chalk.blue('💡 查看所有服务商: ccman cx list\n'))
        process.exit(1)
      }

      codex.switchProvider(provider.id)

      console.log(chalk.green('\n✅ 切换成功\n'))
      console.log(`  ${chalk.bold(provider.name)} ${chalk.blue('[Codex]')}`)
      console.log(chalk.gray('  配置已更新：~/.codex/config.toml\n'))
    })

  // ccman cx current
  codexCmd
    .command('current')
    .description('查看当前 Codex 服务商')
    .action(() => {
      const current = codex.getCurrentProvider()

      if (!current) {
        console.log(chalk.yellow('\n⚠️  暂无激活的服务商'))
        console.log(chalk.blue('💡 切换服务商：ccman cx use <name>\n'))
        return
      }

      console.log(chalk.bold('\n📍 当前 Codex 服务商：\n'))
      console.log(`  ${chalk.green.bold(current.name)}`)
      console.log(`  ${chalk.gray(`URL: ${current.baseUrl}`)}`)
      console.log()
    })
}
```

### 8.2 CLI Layer - commands/status.ts

```typescript
// packages/cli/src/commands/status.ts

import { Command } from 'commander'
import { codex, claudeCode } from '@ccman/core'
import chalk from 'chalk'

export function statusCommand(program: Command): void {
  program
    .command('status')
    .description('查看 Codex 和 Claude Code 状态')
    .action(() => {
      const codexCurrent = codex.getCurrentProvider()
      const claudeCurrent = claudeCode.getCurrentProvider()

      console.log(chalk.bold('\n📊 当前状态\n'))

      // Codex 状态
      console.log('┌─────────────────────────────────────────────┐')
      console.log('│ ' + chalk.blue.bold('Codex') + '                                       │')

      if (codexCurrent) {
        console.log('│   ' + chalk.green('● ') + chalk.bold(codexCurrent.name.padEnd(40)) + '│')
        console.log('│   ' + chalk.gray(`URL: ${codexCurrent.baseUrl}`.padEnd(43)) + '│')
        console.log('│   ' + chalk.gray('配置: ~/.codex/config.toml'.padEnd(43)) + '│')
      } else {
        console.log('│   ' + chalk.yellow('⚠️  未激活'.padEnd(42)) + '│')
      }

      console.log('└─────────────────────────────────────────────┘\n')

      // Claude Code 状态
      console.log('┌─────────────────────────────────────────────┐')
      console.log('│ ' + chalk.magenta.bold('Claude Code') + '                              │')

      if (claudeCurrent) {
        console.log('│   ' + chalk.green('● ') + chalk.bold(claudeCurrent.name.padEnd(40)) + '│')
        console.log('│   ' + chalk.gray(`URL: ${claudeCurrent.baseUrl}`.padEnd(43)) + '│')
        console.log('│   ' + chalk.gray('配置: ~/.claude/settings.json'.padEnd(43)) + '│')
      } else {
        console.log('│   ' + chalk.yellow('⚠️  未激活'.padEnd(42)) + '│')
      }

      console.log('└─────────────────────────────────────────────┘\n')
    })
}
```

---

## 九、测试策略

### 9.1 单元测试

```typescript
// packages/core/__tests__/tool-manager.test.ts

import { describe, it, expect, beforeEach, afterEach } from 'vitest'
import { codex, claudeCode } from '../src/tool-manager'
import { cleanupTestEnv } from '../src/paths'

describe('ToolManager - Codex', () => {
  beforeEach(() => {
    // 确保在测试环境
    process.env.NODE_ENV = 'test'
  })

  afterEach(() => {
    // 清理测试环境
    cleanupTestEnv()
  })

  it('should add provider with auto-generated id', () => {
    const provider = codex.addProvider({
      name: 'Test Provider',
      baseUrl: 'https://api.test.com',
      apiKey: 'sk-test',
    })

    expect(provider.id).toMatch(/^codex-\d+-[a-z0-9]+$/)
    expect(provider.name).toBe('Test Provider')
    expect(provider.createdAt).toBeGreaterThan(0)
  })

  it('should list providers', () => {
    codex.addProvider({
      name: 'Provider 1',
      baseUrl: 'https://api.test1.com',
      apiKey: 'sk-test1',
    })

    codex.addProvider({
      name: 'Provider 2',
      baseUrl: 'https://api.test2.com',
      apiKey: 'sk-test2',
    })

    const providers = codex.listProviders()

    expect(providers).toHaveLength(2)
    expect(providers[0].name).toBe('Provider 1')
    expect(providers[1].name).toBe('Provider 2')
  })

  it('should switch provider', () => {
    const provider = codex.addProvider({
      name: 'Test Provider',
      baseUrl: 'https://api.test.com',
      apiKey: 'sk-test',
    })

    codex.switchProvider(provider.id)

    const current = codex.getCurrentProvider()

    expect(current).not.toBeNull()
    expect(current!.id).toBe(provider.id)
    expect(current!.lastUsedAt).toBeGreaterThan(0)
  })
})
```

### 9.2 集成测试

```typescript
// packages/core/__tests__/integration.test.ts

import { describe, it, expect, beforeEach, afterEach } from 'vitest'
import { codex } from '../src/tool-manager'
import { getCodexDir } from '../src/paths'
import { cleanupTestEnv } from '../src/paths'
import fs from 'fs'
import path from 'path'
import TOML from '@iarna/toml'

describe('Integration - Codex Config Writing', () => {
  beforeEach(() => {
    process.env.NODE_ENV = 'test'
  })

  afterEach(() => {
    cleanupTestEnv()
  })

  it('should write Codex config files when switching provider', () => {
    // 添加服务商
    const provider = codex.addProvider({
      name: 'Test Provider',
      baseUrl: 'https://api.test.com',
      apiKey: 'sk-test-123',
    })

    // 切换服务商
    codex.switchProvider(provider.id)

    // 验证 config.toml 文件
    const codexDir = getCodexDir()
    const configPath = path.join(codexDir, 'config.toml')

    expect(fs.existsSync(configPath)).toBe(true)

    const configContent = fs.readFileSync(configPath, 'utf-8')
    const config = TOML.parse(configContent)

    expect(config.model_provider).toBe('Test Provider')
    expect(config.model_providers['Test Provider']).toEqual({
      name: 'Test Provider',
      base_url: 'https://api.test.com',
      wire_api: 'responses',
      requires_openai_auth: true,
    })

    // 验证 auth.json 文件
    const authPath = path.join(codexDir, 'auth.json')

    expect(fs.existsSync(authPath)).toBe(true)

    const authContent = fs.readFileSync(authPath, 'utf-8')
    const auth = JSON.parse(authContent)

    expect(auth.OPENAI_API_KEY).toBe('sk-test-123')
  })
})
```

### 9.3 环境隔离测试

```typescript
// packages/core/__tests__/env-isolation.test.ts

import { describe, it, expect, beforeEach, afterEach } from 'vitest'
import { getCcmanDir, getCodexDir, getClaudeDir } from '../src/paths'
import os from 'os'

describe('Environment Isolation', () => {
  const originalEnv = process.env.NODE_ENV

  afterEach(() => {
    process.env.NODE_ENV = originalEnv
  })

  it('should use home directory in production', () => {
    process.env.NODE_ENV = 'production'

    const ccmanDir = getCcmanDir()
    const codexDir = getCodexDir()
    const claudeDir = getClaudeDir()

    expect(ccmanDir).toBe(`${os.homedir()}/.ccman`)
    expect(codexDir).toBe(`${os.homedir()}/.codex`)
    expect(claudeDir).toBe(`${os.homedir()}/.claude`)
  })

  it('should use temp directory in development', () => {
    process.env.NODE_ENV = 'development'

    const ccmanDir = getCcmanDir()
    const codexDir = getCodexDir()
    const claudeDir = getClaudeDir()

    expect(ccmanDir).toContain('/ccman-dev/.ccman')
    expect(codexDir).toContain('/ccman-dev/.codex')
    expect(claudeDir).toContain('/ccman-dev/.claude')

    expect(ccmanDir).not.toContain(os.homedir())
  })

  it('should use unique temp directory in test', () => {
    process.env.NODE_ENV = 'test'

    const ccmanDir = getCcmanDir()
    const codexDir = getCodexDir()
    const claudeDir = getClaudeDir()

    expect(ccmanDir).toContain(`/ccman-test-${process.pid}/.ccman`)
    expect(codexDir).toContain(`/ccman-test-${process.pid}/.codex`)
    expect(claudeDir).toContain(`/ccman-test-${process.pid}/.claude`)

    expect(ccmanDir).not.toContain(os.homedir())
  })
})
```

---

## 十、与旧设计的对比

### 10.1 核心差异

| 维度 | 旧设计 | 新设计 | 改进 |
|------|--------|--------|------|
| **配置文件** | 混在一起（`config.json`） | 分离（`codex.json` + `claudecode.json`） | ✅ 清晰分离 |
| **数据结构** | `providers: Provider[]`（含 type） | 两个独立配置（无 type） | ✅ 消除判断 |
| **命令结构** | `ccman add`（不明确） | `ccman cx add` / `ccman cc add` | ✅ 明确工具 |
| **预设服务商** | 混在一起，用后缀区分 | 分离（`CODEX_PRESETS` / `CLAUDECODE_PRESETS`） | ✅ 符合需求 |
| **Core API** | `addProvider(input)`（需传 type） | `codex.addProvider(input)` | ✅ 无需 type |
| **代码复杂度** | 到处都是 `if (type === ...)` | 工厂函数，零判断 | ✅ 代码简洁 |
| **环境隔离** | ❌ 无环境隔离 | ✅ 开发/测试/生产分离 | ✅ 不影响生产 |
| **用户体验** | "开盲盒" | 清晰、明确 | ✅ 心智负担低 |

### 10.2 代码量对比

| 模块 | 旧设计 | 新设计 | 减少 |
|------|--------|--------|------|
| Core Layer | ~300 行 | ~200 行 | -33% |
| CLI Layer | ~400 行 | ~300 行 | -25% |
| **总计** | ~700 行 | ~500 行 | **-28%** |

### 10.3 概念复杂度对比

| 维度 | 旧设计 | 新设计 |
|------|--------|--------|
| **核心概念数** | 5（Config, Provider, type, Presets, Writers） | 4（ToolConfig, Provider, Presets, Writers） |
| **用户需要理解的概念** | 3（工具、type、服务商） | 2（工具、服务商） |
| **CLI 参数** | 2（command, options） | 3（tool, command, options）|

**说明**：虽然 CLI 参数多了一个 `tool`，但用户心智负担更低，因为明确知道在操作哪个工具。

---

## 总结

### ✅ 核心优势

1. **架构清晰**：三层架构（CLI → Core → Writers），职责单一
2. **数据分离**：Codex 和 Claude Code 完全独立
3. **环境隔离**：开发/测试/生产环境分离，不影响正式配置
4. **用户友好**：命令明确（`cx` vs `cc`），零歧义
5. **代码简洁**：函数式实现，代码量减少 28%
6. **易于测试**：环境隔离 + Mock 函数

### 🚀 实施路径

1. **Phase 1**：Core 层重构（paths.ts + tool-manager.ts）
2. **Phase 2**：CLI 层重构（命令结构调整）
3. **Phase 3**：Writers 层适配（环境感知）
4. **Phase 4**：测试完善（单元测试 + 集成测试）
5. **Phase 5**：文档更新 + 发布

**总工时估算**：8-12 小时

---

**版本历史**：
- v2.0 (2025-01-07): 最终方案，增加环境配置、完善架构设计
- v1.0 (2025-01-07): 初始架构方案
