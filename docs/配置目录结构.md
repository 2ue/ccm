# 配置目录结构说明

## 概览

ccman 使用三个主要配置目录：

```
~/
├── .ccman/            # ccman 自身配置（服务商管理）
│   ├── codex.json
│   └── claudecode.json
├── .codex/            # Codex 官方配置目录（只读）
│   ├── config.toml
│   └── auth.json
└── .claude/           # Claude Code 官方配置目录（只读）
    └── settings.json
```

**设计原则**：
- ✅ `.ccman/` 是我们管理的配置（读写）
- ⚠️ `.codex/` 和 `.claude/` 是官方工具的配置（只修改我们管理的字段）
- ✅ 零破坏性：保留用户的其他自定义配置

---

## 一、.ccman 目录（我们管理的）

### 目录结构

```
~/.ccman/
├── codex.json         # Codex 服务商配置
└── claudecode.json    # Claude Code 服务商配置
```

### 1.1 codex.json

**用途**: 存储 Codex 的服务商列表、当前使用的服务商、用户自定义预置。

**格式**:
```json
{
  "current": "codex-1234567890-abc123",
  "providers": [
    {
      "id": "codex-1234567890-abc123",
      "name": "anthropic",
      "baseUrl": "https://api.anthropic.com",
      "apiKey": "sk-ant-...",
      "createdAt": 1234567890,
      "lastUsedAt": 1234567891
    },
    {
      "id": "codex-1234567892-def456",
      "name": "anyrouter",
      "baseUrl": "https://anyrouter.top",
      "apiKey": "sk-...",
      "createdAt": 1234567892
    }
  ],
  "presets": [
    {
      "name": "my-custom-api",
      "baseUrl": "https://api.example.com",
      "description": "我的自定义 API"
    }
  ]
}
```

**字段说明**:
- `current`: 当前激活的 provider ID（可选）
- `providers`: 用户添加的服务商列表（包含 API Key）
  - `id`: 唯一标识符（自动生成，格式：`codex-{timestamp}-{random}`）
  - `name`: 显示名称（用户可见）
  - `baseUrl`: API Base URL
  - `apiKey`: API 密钥
  - `createdAt`: 创建时间（Unix timestamp）
  - `lastUsedAt`: 最后使用时间（Unix timestamp，可选）
- `presets`: 用户自定义预置（不包含 API Key，可选）

### 1.2 claudecode.json

**用途**: 存储 Claude Code 的服务商列表、当前使用的服务商、用户自定义预置。

**格式**: 与 `codex.json` 相同，只是 ID 前缀为 `claudecode-`。

```json
{
  "current": "claudecode-1234567890-xyz789",
  "providers": [
    {
      "id": "claudecode-1234567890-xyz789",
      "name": "openai",
      "baseUrl": "https://api.openai.com/v1",
      "apiKey": "sk-...",
      "createdAt": 1234567890
    }
  ],
  "presets": []
}
```

---

## 二、.codex 目录（Codex 官方配置）

### 目录结构

```
~/.codex/
├── config.toml        # Codex 主配置
└── auth.json          # Codex 认证信息（Anthropic 官方）
```

### 2.1 config.toml

**所有者**: Codex 官方工具

**我们修改的字段**:
```toml
model_provider = "anthropic"  # 当前使用的服务商名称

[model_providers.anthropic]
base_url = "https://api.anthropic.com"
api_key = "sk-ant-..."
```

**我们保留的字段**（不修改）:
- `model_reasoning_effort`: 推理强度
- `disable_response_storage`: 是否禁用响应存储
- 其他用户自定义配置

**原理**:
- 读取现有 `config.toml`（使用 `@iarna/toml` 解析）
- 只更新 `model_provider` 和 `model_providers.{name}` 字段
- 保留其他所有字段
- 写回文件（原子操作）

### 2.2 auth.json

**用途**: Anthropic 官方认证（我们不修改）

**格式**:
```json
{
  "session_key": "...",
  "expires_at": "..."
}
```

**注意**: 这个文件由 Codex 官方工具管理，ccman 不会读写。

---

## 三、.claude 目录（Claude Code 官方配置）

### 目录结构

```
~/.claude/
└── settings.json      # Claude Code 主配置
```

### 3.1 settings.json

**所有者**: Claude Code 官方工具

**我们修改的字段**:
```json
{
  "env": {
    "ANTHROPIC_AUTH_TOKEN": "sk-ant-...",
    "ANTHROPIC_BASE_URL": "https://api.anthropic.com"
  }
}
```

**我们保留的字段**（不修改）:
- `permissions`: 权限配置
- `CLAUDE_CODE_MAX_OUTPUT_TOKENS`: 输出 token 限制
- 其他环境变量
- 其他用户自定义配置

**原理**:
- 读取现有 `settings.json`
- 只更新 `env.ANTHROPIC_AUTH_TOKEN` 和 `env.ANTHROPIC_BASE_URL`
- 保留其他所有字段和环境变量
- 写回文件（原子操作）

---

## 四、环境隔离

ccman 支持三种环境，自动切换配置目录：

### 4.1 生产环境（默认）

```bash
# 用户主目录
~/.ccman/
~/.codex/
~/.claude/
```

### 4.2 开发环境

```bash
export NODE_ENV=development
ccman  # 使用开发环境配置

# 临时目录（共享）
/tmp/ccman-dev/.ccman/
/tmp/ccman-dev/.codex/
/tmp/ccman-dev/.claude/
```

### 4.3 测试环境

```bash
export NODE_ENV=test
pnpm test  # 自动使用测试环境

# 临时目录（每个测试进程独立）
/tmp/ccman-test-{PID}/.ccman/
/tmp/ccman-test-{PID}/.codex/
/tmp/ccman-test-{PID}/.claude/
```

**实现**: 见 `packages/core/src/paths.ts`

---

## 五、内置预置服务商

### 存储位置

内置预置服务商**硬编码**在代码中，**不写入文件**。

**代码位置**:
- `packages/core/src/presets/codex.ts` - Codex 预置
- `packages/core/src/presets/claudecode.ts` - Claude Code 预置

**Codex 内置预置** (7 个):
```typescript
export const CODEX_PRESETS: PresetTemplate[] = [
  { name: 'Anthropic Official', baseUrl: 'https://api.anthropic.com', ... },
  { name: 'AnyRouter', baseUrl: 'https://anyrouter.top', ... },
  { name: 'PackyCode', baseUrl: 'https://api.packycode.com', ... },
  { name: 'CoordCode', baseUrl: 'https://api.coordcode.com/api', ... },
  { name: '88Code', baseUrl: 'https://www.88code.org/api', ... },
  { name: 'BigModel', baseUrl: 'https://open.bigmodel.cn/api/anthropic', ... },
  { name: 'ModelScope', baseUrl: 'https://api-inference.modelscope.cn/v1/chat/completions', ... },
]
```

**Claude Code 内置预置** (类似，包含 OpenAI、Azure 等)

### 使用流程

1. **列出预置**: 内置预置 + 用户自定义预置
   ```typescript
   manager.listPresets() // → CODEX_PRESETS + config.presets
   ```

2. **从预置创建服务商**:
   ```bash
   ccman cx add
   # 交互式选择: [1] 从预置创建
   # 选择预置: [1] Anthropic Official
   # 输入 API Key: sk-ant-...
   # → 创建新的 provider
   ```

3. **添加用户预置**:
   ```bash
   ccman cx add-preset
   # 输入名称: my-custom-api
   # 输入 Base URL: https://api.example.com
   # 输入描述: 我的自定义 API
   # → 保存到 .ccman/codex.json 的 presets 字段
   ```

### 为什么内置预置不写入文件？

**Linus 的判断**:
> "Code is the only source of truth for default values."

**原因**:
1. **简洁性**: 不需要在初始化时生成文件
2. **可维护性**: 更新内置预置只需修改代码，不需要迁移文件
3. **清晰性**: 内置（只读）和用户自定义（可编辑）清晰分离
4. **包大小**: 不需要在发布包时包含 JSON 文件

---

## 六、数据流

### 6.1 添加服务商流程

```
用户输入
  ↓
选择预置或手动输入
  ↓
manager.add({ name, baseUrl, apiKey })
  ↓
生成 ID（codex-{timestamp}-{random}）
  ↓
保存到 .ccman/codex.json
  ↓
（不自动切换）
```

### 6.2 切换服务商流程

```
用户选择服务商（通过 ID 或 name）
  ↓
manager.switch(id)
  ↓
更新 .ccman/codex.json:
  - config.current = id
  - provider.lastUsedAt = Date.now()
  ↓
写入 Codex 官方配置:
  - ~/.codex/config.toml (model_provider, model_providers.{name})
  ↓
完成
```

### 6.3 导出配置流程

```
exportConfig({ includeApiKeys: false })
  ↓
读取 .ccman/codex.json
读取 .ccman/claudecode.json
  ↓
转换 current (ID → name)
如果 !includeApiKeys: 清空 apiKey 字段
  ↓
生成 JSON:
  {
    version: "3.0.2",
    exportedAt: "...",
    includeApiKeys: false,
    data: { codex: {...}, claudecode: {...} }
  }
  ↓
写入文件（权限 0600）
```

### 6.4 导入配置流程

```
importConfig(json, { merge: true })
  ↓
版本检查（兼容性）
  ↓
备份当前配置
  .ccman/backup/codex-{timestamp}.json
  .ccman/backup/claudecode-{timestamp}.json
  ↓
for tool in [codex, claudecode]:
  for preset in json.data[tool].presets:
    if !exists: addPreset(preset)

  for provider in json.data[tool].providers:
    if conflict:
      if skipConflict: continue
      else: rename to "{name} (imported)"
    add(provider)

  if json.data[tool].current:
    provider = findByName(current)
    if provider: switch(provider.id)
  ↓
成功 → 返回 ImportResult
失败 → 回滚（从 backup 恢复）
```

---

## 七、文件权限和安全

### 7.1 文件权限

```bash
~/.ccman/          # 0700（只有所有者可访问）
~/.ccman/*.json    # 0600（只有所有者可读写）
```

**实现**:
```typescript
fs.mkdirSync(ccmanDir, { recursive: true, mode: 0o700 })
fs.writeFileSync(configPath, content, { mode: 0o600 })
```

### 7.2 原子操作

所有配置写入都使用原子操作：

```typescript
function writeConfig(path: string, content: string): void {
  const tempPath = `${path}.tmp`

  // 1. 写入临时文件
  fs.writeFileSync(tempPath, content, { mode: 0o600 })

  // 2. 原子 rename（覆盖原文件）
  fs.renameSync(tempPath, path)
}
```

**好处**:
- 即使进程崩溃，也不会损坏配置文件
- 多进程写入时不会产生部分写入

### 7.3 备份和回滚

导入配置时自动备份：

```typescript
function backupConfig(): void {
  const backupDir = path.join(getCcmanDir(), 'backup')
  fs.mkdirSync(backupDir, { recursive: true })

  const timestamp = Date.now()
  fs.copyFileSync(
    path.join(getCcmanDir(), 'codex.json'),
    path.join(backupDir, `codex-${timestamp}.json`)
  )
}

function restoreBackup(timestamp: number): void {
  fs.copyFileSync(
    path.join(getCcmanDir(), 'backup', `codex-${timestamp}.json`),
    path.join(getCcmanDir(), 'codex.json')
  )
}
```

---

## 八、配置迁移

### 当前版本: 3.0.x

```
~/.ccman/
├── codex.json       # { current, providers[], presets?[] }
└── claudecode.json  # { current, providers[], presets?[] }
```

### 未来版本: 4.0.x（假设）

如果未来需要重大格式变更，使用迁移脚本：

```typescript
// packages/core/src/migrate.ts
export function migrate_3_to_4(): void {
  const config = readJSON('~/.ccman/codex.json')

  // 迁移逻辑
  const newConfig = {
    version: '4.0.0',
    current: config.current,
    providers: config.providers.map(migrateProvider),
    presets: config.presets || [],
    // 新字段
    settings: {}
  }

  writeJSON('~/.ccman/codex.json', newConfig)
}
```

**触发时机**:
- CLI/Desktop 启动时自动检测版本
- 如果配置文件版本 < 当前代码版本，自动迁移
- 迁移前备份

---

## 九、FAQ

### Q: 为什么不把 codex 和 claudecode 配置合并成一个文件？

**A**:
- 职责分离：两个工具的配置完全独立
- 导出导入更灵活：可以只导出/导入一个工具的配置
- 未来扩展：如果支持第三个工具（如 Cursor），直接添加 `cursor.json`

### Q: 为什么 current 存储 ID 而不是 name？

**A**:
- ID 是唯一且不可变的
- name 用户可以修改
- 如果存储 name，用户改名后会找不到 current

### Q: 用户删除了 .ccman 目录会怎样？

**A**:
- CLI/Desktop 下次启动时会自动创建空配置
- 用户需要重新添加服务商
- `.codex/` 和 `.claude/` 不受影响

### Q: 预置服务商列表会更新吗？

**A**:
- 内置预置随 ccman 版本更新
- 用户升级 ccman 后自动获得新的预置
- 用户自定义预置不受影响

### Q: 为什么不用 SQLite 存储配置？

**A**:
- 配置数据量小（< 50KB）
- JSON 文件简单、可读、易调试
- 不需要数据库的查询能力
- "YAGNI: 不要为不存在的问题过度设计"

### Q: 配置文件损坏了怎么办？

**A**:
1. 如果有备份（`.ccman/backup/`），从备份恢复
2. 如果没有备份，删除损坏文件，重新初始化
3. 如果有导出的 JSON，从导出文件导入

---

## 十、设计原则总结

1. **简洁至上**:
   - 2 个配置文件，不需要数据库
   - JSON 格式，零依赖

2. **零破坏性**:
   - 只修改我们管理的字段
   - 保留用户的其他自定义配置

3. **数据结构优先**:
   - ID（唯一、不可变）vs name（用户可见、可变）
   - 内置预置（只读）vs 用户预置（可编辑）

4. **实用主义**:
   - 不做云同步（复杂度高、需求低）
   - 不做自动备份（Time Machine 已做）

5. **安全性**:
   - 文件权限 0600
   - 原子操作
   - 导出时明确警告 API Key

---

**最后提醒**: 如果配置目录结构需要重大变更，必须先更新 `docs/技术架构.md` 和本文档，然后再实现。避免需求偏移。
